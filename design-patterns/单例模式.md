# 单例模式

## 单例模式的特点：

1. 单例类只能有一个实例；
2. 单例类必须自己创建自己的唯一实例；
3. 单例类必须给所有其他对象提供这一实例。


## 懒汉类

```java
// 懒汉式单例类，在第一次调用的时候实例化自己
public class Singleton {
    private Singleton() {
    }

    private volatile static Singleton singleton = null; // 声明成 volatile

    // 静态工厂方法
    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```


## 饿汉类

``` java
// 饿汉式单例类，在类初始化时，已经自行实例化
public class Singleton {
    private Singleton() {
    }

    private static final Singleton single = new Singleton();

    // 静态工厂方法
    public static Singleton getInstance() {
        return single;
    }
}
```

但当单例类当实现了 `Serializable` 接口后，反序列化时单例会被破坏，此时需要重写 `readResolve`，才能保证其反序列化依旧是单例，如下所示：

``` java
private Object readResolve() throws ObjectStreamException {
    return single;
}  
```


## 内部静态类（推荐）

```java
public class Singleton {
    private static class LazyHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    private Singleton() {
    }

    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}
```


## 枚举类

``` java
public enum Singleton {
    INSTANCE;

    public void whateverMethod() {
    }
}
```


## 结语

我正在打造一个帮助 Android 开发者们拿到更好 offer 的面试库————**[安卓 offer 收割基](https://github.com/Blankj/AndroidOfferKiller)**，欢迎 star，觉得不错的可以持续关注，有兴趣的可以一起加入进来和我一同打造。